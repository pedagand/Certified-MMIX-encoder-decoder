\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{color}
\setlength{\fboxsep}{0pt}
\newcommand{\highlight}[1]{\text{\colorbox{gray}{$#1$}}}


\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
    {lambda}{{$\lambda$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.v}}
           \newcommand{\fun}[1]{\lstinline!#1!}

\newcommand{\intg}{\ensuremath{\mathsf{int}}}
\newcommand{\bool}{\ensuremath{\mathsf{bool}}}
\newcommand{\Lam}[2]{\ensuremath{\lambda #1\: #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}
\newcommand{\Fst}[1]{\ensuremath{#1.\pi_0}}
\newcommand{\Snd}[1]{\ensuremath{#1.\pi_1}}
\newcommand{\Pair}[2]{\ensuremath{(#1, #2)}}
\newcommand{\ifte}[4]{\ensuremath{\mathsf{ifte}\:#1\: #2\:\:#3\:\: #4}}
\newcommand{\true}{\ensuremath{\mathsf{true}}}
\newcommand{\false}{\ensuremath{\mathsf{false}}}
\newcommand{\zero}{\ensuremath{\mathsf{zero}}} 
\newcommand{\succs}{\ensuremath{\mathsf{succ}}}
\newcommand{\iter}{\ensuremath{\mathsf{iter}}}
\newcommand{\subst}[3]{#1[#2 := #3]}
\newcommand{\Inv}[1]{\ensuremath{\mathsf{inv}(#1)}}
\newcommand{\Ann}[2]{\ensuremath{(#1\: :\: #2)}}
\newcommand{\equal}[3]{\ensuremath{#1 =_#2 #3}} 
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}
\newcommand{\id}[3]{\ensuremath{\mathsf{id}\:#1\: #2\:\:#3}}
\newcommand{\vect}[2]{\ensuremath{\mathsf{vec}\:#1\: #2}}
\newcommand{\dfold}[6]{\ensuremath{\mathsf{fold}\:#1\:#2\:#3\:#4\:#5\:#6}}
\newcommand{\cons}[2]{\ensuremath{\mathsf{cons}\:#1\: #2}}


\setbeamertemplate{navigation symbols}{} 

\usetheme{Boadilla}

\title{Assembleur Certifié}

\author{Roman Delgado}

\institute[\textsc{Upmc}]{Université Pierre et Marie Curie}

\date{31/05/2016}


\begin{document}


\begin{frame}

\titlepage

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Introduction}

  \begin{block}{Objectifs du projet}
    \begin{itemize}
    \item Apprentissage du langage Coq
    \item Réaliser un assembleur certifié
    \end{itemize}
  \end{block}

  \begin{block}{Pourquoi certifié un assembleur}
    \begin{itemize}
    \item Bugs KVM (décodage des instructions)
    \item Fin de la chaîne de compilation 
    \end{itemize}
  \end{block}   
  %surtout au niveau du decodage que c'est la galère , on ne peut pas vraiment allez plus loins que ça après c'est le matériel
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]

\frametitle{Programmes certifiés}

\vfill

\begin{block}{Qu'es ce qu'un programme certifié}
  \begin{itemize}
  \item Une spécification formelle
  \item Des preuves garantissants que le programme est conforme à la spécification
  \end{itemize}
\end{block}
\begin{block}{Comment faire avec le langage Coq}
  \begin{itemize}
  \item Coq est un assistant de preuve
  \item Programme écrit avec Coq 
  \item Preuves égalements vérifiés par Coq.
  \item Programme vérifié = programme prouvé      
  \end{itemize}
\end{block}
\vfill


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Certifié un Assembleur}

%%L'assembleur est un traducteur entre un langage cible et un langage source Pour mmix on peut voir le fait de faire un assembleur
%%comme définir une relation isomorphique entre les deux ensembles alors que pour x86 c'est pas vrais


%je met pas les mêmes parceque elles ne possèdent pas le même ensemble de définition
\begin{block}{Fonctions Inverses}
\begin{itemize}
    \item Encodage(Decodage(x)) = x
    \item Decodage(Encodage(y)) = y 
\end{itemize}  
\end{block}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{x86 vs MMIX}

\begin{block}{x86}
  \begin{itemize}
    \item Taille des instructions variables
    \item Une même instruction possède différents encodages
    \item De nombreux champs dans une instruction (tag, ect..)
    \end{itemize}  
\end{block}

\begin{block}{MMIX}
  \begin{itemize}
  \item Jeu d'instruction RISC (taille des instructions fixée)
  \item Format des instructions très simple
  \end{itemize}  
\end{block}

\vfill

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Partialité} 

\begin{block}{Monade option}
  \begin{itemize}
  \item Mécanisme pour gérer les fonctions partiels dans les langages fonctionels
  \item Mettre la définition du type option     
  \end{itemize}  
\end{block}




\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Récursion} 

\begin{block}
  Mettre le code ocaml de la fonction de décodage des bits
\end{block}


\begin{block}
  Mettre le code coq de la fonction de décodage des bits
\end{block}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Réflexion} 

\begin{block}
Mettre juste la spec de ce que l'on veut prouver dans le monde propositionel
\end{block}


\begin{block}
  Résumé des bénéfices (terme de preuve plus petit) (plus besoin de faire une étude de cas pour chaque nouvelles preuves)
\end{block}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Conversion $\mathbb{N}$ vers liste $\mathbb{B}$} 

\begin{block}{Pourquoi une telle conversion}
  \begin{itemize}
  \item Un $\mathbb{B}$ représente un bit
  \item Une instruction binaire sera donc une liste de booléens
  \item Permet l'utilisation de la récursion ainsi que 
  \end{itemize}   
\end{block}

\begin{block}{Objectifs de la section}
  \begin{itemize}
  \item Définir deux fonctions de conversion
  \item Prouver que celles ci sont des fonctions inverses
  \end{itemize}   
\end{block}

\begin{block}{Les difficultés}
  \begin{itemize}
  \item Spécificité de la récursion avec Coq
  \item Fonctions partielles
  \end{itemize}   
\end{block}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Conversion $\mathbb{N}$ vers liste $\mathbb{B}$} 


\begin{block}{n\_bit}
  \fontsize{8}{10}
  \codefrom{src}{binary}{nbit}
\end{block}



\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Conversion $\mathbb{N}$ vers liste $\mathbb{B}$} 

\begin{block}{Théorèmes}
    \fontsize{8}{10}
  \codefrom{src}{binary}{nbitn}
  \codefrom{src}{binary}{bitnbit}
\end{block}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
  \frametitle{Représentation des données}
  \begin{block}{Les tags}
    
  \end{block}

  




\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
  \frametitle{Associtation tag vers liste B}
  \begin{block}{Objectifs de la section}
    \begin{itemize}
    \item Associer chaque tag à son code binaire de façon statique (liste d'association)
    \item Définir deux fonctions de recherche dans la liste
    \item Montrer qu'elle sont inverses
    \end{itemize}   
  \end{block}

  \begin{block}{Réflexion}
    Permet d'utiliser le calcul afin de prouver les propositions
  \end{block}
  
 
\begin{block}{Les difficultés}
  \begin{itemize}
  \item Utilisation de la réflexion
  \end{itemize}   
\end{block}
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
  \frametitle{Encodage et Decodage}
  \begin{block}{Objectifs de la section}
    \begin{itemize}
    \item Définir les fonctions d'encodage et de décodage d'une instruction
    \item Montrer qu'elles sont inverses
    \end{itemize}   
  \end{block}  
  
\begin{block}{Les difficultés}
  \begin{itemize}
  \item Utilisation de l'ensemble des théorèmes précédents
  \item ``Machinerie avec Coq''
  \end{itemize}   
\end{block}
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Flux d'instructions}
  \begin{block}{Objectifs de la section}
    \begin{itemize}
    \item Définir les fonctions d'encodage et de décodage d'une instruction
    \item Montrer qu'elles sont inverses
    \end{itemize}   
  \end{block}  
  
\begin{block}{Les difficultés}
  \begin{itemize}
  \item Découpage des instructions
  \item Preuves arithmétiques
  \end{itemize}   
\end{block}
  
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Comment passer à x86}
  
  \begin{block}{Pourquoi ce n'est pas possible}
    Le problème majeur est la représentation des données actuelle.
    Cela implique aussi une modification de la liste d'association.
  \end{block}  
  
\begin{block}{Les pistes}
  \begin{itemize}
  \item Utiliser la technique des librairies de parseur fonctionels
  \end{itemize}   
\end{block}
  
\end{frame}







\end{document}

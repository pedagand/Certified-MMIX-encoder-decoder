\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
  {->}{{${\to}$}}2
  {*}{{${\times}$}}1
  {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.v}}

\newcommand{\codefromOcaml}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}
           
%% ** Theorem styles 
           
           
\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\question}[1]{\textcolor{green}{#1}}
\newcommand{\etc}{\textit{etc.}}

\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}
               
\newcommand{\fun}[1]{\lstinline!#1!}
%% ** Title

\title{Assembleur x86 certifié}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 

\vfill
\setcounter{tocdepth}{2}
\tableofcontents
\vfill


\section{Introduction}

\todo{parler du fait que le but pour les assembleurs que l'on va définir est d'avoir une preuve dans les deux sens
  que l'encodage et le decodage préserve l'instruction (a bien rédiger haha)}

Un assembleur est un programme permettant de traduire des instructions lisibles par un être humain vers
une leur représentation binaire associée afin d'être éxécutées par le processeur. Contrairement à un compilateur
qui effectue lui aussi un travail de traduction, l'assembleur se focalise uniquement sur l'analyse syntaxique
et non sur l'aspect sémantique.
Il existe de nombreux langages
assembleurs pour cité les plus connus \todo{mettre les plus connus}.
Le programme KVM \todo{mettre une ref} qui fait partie du noyau linux depuis la version \todo{mettre la version}
permet d'effectuer cette traduction \todo{chercher si c'est que pour x86}.
Cependant certains problèmes on été relevées au niveau de la \todo{Chercher un mot}.
Même si ces problèmes on été résolus on ne peut à l'heure actuelle pas garantire que d'autre bugs ne seront pas
découvert dans les années à venir.

Prenons l'exemple d'un autre logiciel dont l'utilisation est très répandue : gcc. C'est le compilateur
du langage C le plus utilisé à l'heure actuelle \todo{Pas sur haha} et pourtant il existe encore des
problèmes avec celui ci. C'est ce qu'a démontré Xavier Leroy en concevant un compilateur certifié pour le langage C ``Compcert''
\todo{mettre un max de ref}. Après avoir développé celui ci il à comparé les résultats de ``Compcert'' avec ``GCC''
et il a relevé plus de \todo{mettre les chiffres et finir la phrase}.


Mais comment garantir qu'un programme s'éxécute correctement, en quoi consiste la réalisation d'un logiciel certifié.
Ces questions sont des questions centrales depuis le développement de l'informatique, et de nombreux travaux ont été
réalisées sur ce sujet. Les méthodes pour atteindre cet objectif sont diverses \todo{parler des différentes méthodes qui éxistent et dire
que on va choisir les assistants de preuve}.


Les assistants de preuves permettent de crée des programmes sur lesquels on énonce des propriétés que l'on prouve par
la suite avec celui ci. 
Par exemple le noyau de coq a été prouvé donc on est en droit de (après on ne sais jamais si une faille ne sera pas découverte
mais cela réduit énormément la probabilité de recontrer un bug \todo{finir cette petite partie}

La difficulté lors de la réalisation d'un assembleur ne se situe pas en hauteur en effet le nombre de
fonctions nécéssaires n'est pas très conséquent \todo{bof reformuler}. Par contre la complexité en largeur
de ce type de programme est très grande. Cela est due au nombre d'instructions ainsi qu'a leur syntaxe qui selon
la spécification du langage peut etre particulière.
Les assistants de preuves se prêtent très bien à ce genre de problème car l'on peut prouver des
propriétés sur des ensembles (dans notre cas des instructions) et réaliser une seul preuve pour
un ensemble donné.

Une motivation supplémentaire est la continuation des travaux menés par \todo{mettre des noms}.
Le compilateur ``Compcert'' génère de du langage assembleur x86, mais il n'existe pas
de programme permettant de garantire sa traduction en bits.
C'est donc le but de ce projet qui est la réalisation d'un assembleur x86 certifié.

Afin de mener a bien ce projet et au vus de la complexité de la specification de x86,
nous allons tout d'abord réaliser un assembleur préliminaire basé sur le langage MMIX.




%%--------------------------------------MMIX et représentation des données-----------------
\section{MMIX et représentation des données}
\label{partieMMIX}

\todo{finir cette introduction}
Le langage d'assembleur MMIX à été crée par Donald Knuth en 1999.
A l'heure actuelle il n'existe aucun processeur utilisant ce jeu d'instructions, il
à été crée et utilisée dans un but pédagogique.



%%-------------Definition---------------
\subsection{Définition MMIX}

Dans cette section il sera question de définir la syntaxe des instructions MMIX.
MMIX est un jeu d'instruction RISK ce qui signifie que la taille des instructions
est fixe. Une instruction a une taille de 32 bits, voici une première représentation:

\begin{tabular}{|c|c|c|c|}
  \hline
  Etiquette & Operande 1 & Operande 2 & Operande 3\\
  \hline
  0-7 bits & 8-15 bits & 16-23 bits & 24-31  \\
  \hline
  TAG & X & Y & Z \\
  \hline
\end{tabular}
\remark{La dernière ligne du tableau permet simplement d'associer à chaque partie
  de l'instruction un nom de variable afin d'alléger le texte dans la suite du rapport}\\
Les operandes peuvent être à la fois un immediat ou un registre.
Une de ses spécificité de MMIX est la possibilité d'obtenir des operandes
de plus grande taille en utilisant un nombre réduit de celles ci:\\

\begin{tabular}{|c|c|c|}
  \hline 
  TAG & X & YZ \\
  \hline
\end{tabular}
\begin{tabular}{|c|c|}
  \hline 
  TAG & XYZ \\
  \hline
\end{tabular}

\todo{ce tableau ...}



%%-------------Representation---------------
\subsection{Représentation des données}
\label{representation des donnees}

Dans un premier temps j'ai fait le choix d'utiliser une représentation des données très exaustive sans
chercher à la factoriser. Ce choix est due à mon apprentissage de Coq, il était préférable de ne pas
rajouter une difficulté supplémentaire lors de la réalisation des preuves.
Un autre choix à été de stocker l'information sur la syntaxe de l'instruction dès les étiquettes.
Cela permettra de ne pas mettre cette information dans la liste d'association, nous y reviendrons dans la
section \ref{partieOpcode}.

\codefrom{src}{ast_instructions}{tag}

Chaque type d'étiquette sera associé à une syntaxe d'instruction par exemple le type ``tag\_ter\_normal''
regroupe les tags ne pouvant être utilisés que pour les instructions dont les opérandes sont trois registres.

\codefrom{src}{ast_instructions}{tag_definition}
...

\remark{Pour un langage assembleur tel que x86 il ne sera pas possible de definir les instructions de façon exhaustive il faudra
  utiliser une autre représentation des données.}\\ 

Maintenant nous voulons définir un type de donnée qui puisse représenter une instruction.
Etant donné que nous avons dissocié les différents types de tag en fonction de la syntaxe de l'instruction,
nous allons poursuivre de manière analogue.
En voici un exemple pour les instructions dont les 3 opérandes représentes des registres.

\codefrom{src}{ast_instructions}{instruction_tern_n}

L'utilisation du type enregisrement convient parfaitement pour réprésenter car il permet de stocker
l'ensemble des informations de celles ci.

Nous obtenons donc le type suivant pour les instructions:
\codefrom{src}{ast_instructions}{instruction}




%%-------------Egalité---------------
\subsection{Egalité entre deux éléments d'un type de donnée}
Avant de passer à la section suivante attardons nous sur l'égalité de deux éléments de même type.
\remark{Dans cette section nous nous attarderons uniquement sur les types de données iductifs}\\
Si l'on souhaite définir une égalité pour le type de donnée suivant :
\codefrom{rapport}{definitions}{example_type}

Il va nous falloir crée une fonction exhaustive énumérant l'ensemble des cas pour determiner
si les deux élements sont égaux ou non. Ce qui nous donne pour l'exemple précédent la fonction suivante:

\codefrom{rapport}{definitions}{equal}

Ce genre de fonctions sont très fastidieuses à rédiger et l'on constate déja la taille de celle ci
pour un type de donnée composé de deux éléments.
Si nous souhaitions écrire cette fonction le type \fun{tag} dans
la section \ref{representation des donnees} la perte de temps serait considérable.
Dans Coq il existe une commande qui va nous permettre de générer cette fonction
automatiquement, la voici:

\codefrom{rapport}{definitions}{SchemeEqual}



%%-------------Lemmes---------------
\subsection{Lemmes}
\label{LemmesAST}
Voici un premier lemme qui nous sera très utile par la suite:
\codefrom{src}{ast_instructions}{tag_beq_different}
Ici on désire montrer que si l'on prossède une preuve que deux étiquettes sont équivalentes
à l'aide de notre fonction booléene alors on peut déduire une preuve
de cette égalité dans le monde propositionnel.








%%----------------------------------------Section Conversion N liste B -----------------------------
\section{Conversion N liste B}
\label{Section Conversion N liste B}
\todo{faire une petite intro la dessus}


%------------repres bits ----------------
\subsection{Représentation des bits}
\todo{Enfaite il faut parler de suite de bits (enfin c'est pas le bon mot) mais pas de bits tout court}

Dans la section \ref{representation des donnees} nous avons parlé de la représentation des instructions
sous forme \todo{trouver le mot}. Maintenant il nous faut choisir un type de donnée pour représenter
les instructions sous forme binaires.
Notre type de donnée doit pouvoir nous permettre de :
\begin{enumerate}
\item Pouvoir recevoir une chaine de bits de taille n quelconque et multiple de 32 de tel sorte que
  lors d'un parsing d'un fichier binaire il n'y ai pas de traitement supplémentaire à faire.
\item Il doit être simple car il est préférable que les preuves qui sont le coeur de ce projet restent
  plus aisées à mettre en place.
\end{enumerate}

Il existe dans la librairie standard de Coq une représentation binaire pour les entiers naturels.
Le problème de celle ci est que l'on ne peut pas représenter un entier naturel sur un nombre de bits différents
que celui nécéssaire à son encodage. Nous ne pouvons pas nous permettre d'avoir une taille variable en
fonction de la valeur encodée et cela contredirait le premier pré-requis que nous souhaitons.

La structure de donnée par excellence qui satisfait l'ensemble de nos prérequis est la liste.
En effet elle permet de répondre à ces deux besoins, nous utiliserons donc des listes de booléens.
\todo{je vais quand même pas dire que false c'est 0 et true c'est 1 non? :p}

\codefrom{src}{ast_instructions}{binary_instruction}




%-------------Fcts de conversion --------------
\subsection{Fonctions de conversion}
\label{Fonctions de conversion}
Maintenant que nous avons fixé une représentation pour nos suite de bits, commençons par définir
une fonction de conversion d'une liste de booléens vers un entier naturel:

\codefrom{src}{binary}{bitn}

Commençons par prêtter attention à cette fonction car elle est une simple implémentation
d'une formule bien connue pour determiner la valeur d'un nombre sous forme binaire
en forme décimal. Passons maintenant à la fonction effectuant l'opération inverse:

\codefrom{src}{binary}{nbit}


Ici cette fonction possède plusieurs subtilités d'implémentation dues à des restrictions du
à une restriction du langage Coq.

La première chose que l'on peut remarquer se situe au niveau des arguments de
la fonction. En effet nous souhaitons simplement encoder un entier naturel vers
une liste de booléens et pourtant nous avons deux arguments.
En réalité nous souhaiterions pouvoir écrire notre fonction comme ceci
(implémentation en Ocaml):
\codefromOcaml{rapport}{example}{nbit}

Cependant cette implémentation est impossible avec Coq car celui ci utilise
des opérateurs de points fixes \todo{lol j'ai pas tout compris à ce truc je suis
  pas sur de ce que je met} et dans ce dernier exemple l'appel récursif ne s'éffectue
pas avec le prédécesseur de ``k'' \todo{again comment citer une var} mais avec le
résultat de ``k'' par deux. \todo{finir ça et trouver la vraie justification tranquillement}
\todo{Placer les ensembles finis (enfin c'est pas le mot exacte)}


\remark{Dans notre cas cette fonction nous convient parfaitement car nous souhaitons
  obtenir une liste de booléens de taille determinée. Cependant cela nous permet d'illustrer
  la façon dont Coq définie la récursion}

\todo{enfaite ça va être la seconde (changer puis supprimer)}
On pourra aussi noter le type de retour de la fonction.
On utilise une monade bien connue des programmeurs fonctionnels au travers du type
``option'' \todo{faut que je retrouve comment faire les quotes}. Cela nous permet de
dire que la fonction peut échouer sans pour autant devoir renvoyer une valeur par
défaut où lever une exception. Ici le cas ou la fonction peut échouer est lorsque
l'entier naturel que l'on souhaite encoder nécéssite plus de bits que l'entier n alors
on ne peut pas réaliser la transformation.





%%--------------Lemmes-----------
\subsection{Lemmes}

Il nous faut maintenant nous demander quelles sont les propriétées qui nous intérressent sur
les deux fonctions que nous venons de définir dans la section \ref{Fonctions de conversion}.

Une propriété qui s'avèrera surement utile par la suite est le Lemme suivant:

En effet cela nous permettra de vérifier qu'une instruction produite par les fonctions
des sections suivantes \todo{mettre la ref} produisent bien des instructions de taille 32.

\codefrom{src}{binary}{size_n_bit}

Une des information importante à retenir de ce théorème est sa structure.
En effet comme nous avons vus précédement \ref{Fonctions de conversion} la
fonction n\_bit peut échouer, il nous faut donc vérifier cette propriété
uniquement lorsque celle ci termine correctement. C'est pour cette raison
que nous devons utiliser l'implication pour ne considérer que ces cas précis. \\

Il est maintenant question de définir les deux théorèmes les plus important de
cette section. Notre but pour l'ensemble des fonctions que l'on définis est de
montrer qu'elles sont \todo{trouver le mot ici (c'est pas symétriques mais un truc dans le genre)}
car elles seront utilisé dans l'encodage et decodage des instructions \todo{mettre la ref}
Voici donc le premier théorème que nous voulons prouver:

\codefrom{src}{binary}{nbitn}

Comme pour le lemme précédent ce théorème suit la même structure d'implication en raison des effets
de bords induit par la monade option.
Pour le théorème suivant nous avons besoin d'émettre une hypothèse supplémentaire sur l'argument
``n'' \todo{encore les vars}. Si nous n'effectuons pas cette assertion supplémentaire le
théorème n'a pas de sens et n'est pas conséquent pas prouvable.

\codefrom{src}{binary}{bitnbit}

\todo{la phrase suivante est nul mais pourquoi pas mettre une petite phrase de conclusion de la partie}
Nous avons en notre possession l'ensemble des théorèmes nécéssaires pour la suite de nos preuves




%%---------------------------Conversion Opcode list B---------------------------
\section{Conversion Etiquette vers N}
\label{partieOpcode}

Une instruction possède une étiquette ainsi que des opérandes (\ref{partieMMIX}).
Pour réussir à encoder ou décoder une instruction il nous faut donc dabord
réussir à convertire une étiquette en un entier N \todo{symbol}.
Pourquoi cette conversion s'effectue vers l'ensemble des entiers naturels
et non vers les listes de B \todo{symbol}, tout simplement pour éviter
de les hardcoder \todo{change}. Nous utiliserons les fonctions définies dans
la section précédente \ref{Section Conversion N liste B} lorsque nous souhaiterons transformer nos entiers naturels.

%%---------Structure de donnée----------------
\subsection{Structure de donnée}
\label{Structure de donnee}
Dans la specification du langage MMIX (section \ref{partieMMIX})
une étiquette est associée à un unique opcode. Nous souhaitons donc
utilisé un type de donnée permettant de realiser l'association de ces deux éléments,
ce qui nous conduit à utiliser le produit cartésien suivant: \todo{je sais pas exactement si je peux dire ça}
\codefrom{src}{association_list}{assoc}

Nous avons maintenant une représentation pour les associations il nous faut
maintenant stocker l'ensemble de celles ci. Etant donné que le nombre
d'instructions est de 256, l'utilisation des listes est envisageable.
Un argument supplémentaire est que la liste
est un type inductif qui nous permettra de raisonner plus aisement
lors des preuves étant donné sa relative simplicité. En effet on pourrait utiliser
un dictionnaire pour réduire la complexité, cependant l'utilisation de ce 
type de donnée rendrais les preuves plus complexes \todo{pas sur au final :p}.
Nous obtenons donc le type suivant pour représenté notre collection d'associations:

\codefrom{src}{association_list}{tag_opcode_assoc}

\remark{L'utilisation des listes à l'instard des
  dictionnaires permet également de n'utiliser qu'une seul liste d'association qui
  permettra d'encoder et de decoder contrairement à ce dernier.
}

\remark{J'ai fait le choix de ne pas me reposer sur la liste d'association pour stocker des informations sur le decodage
  des instructions. En effet lors du décodage avec une telle liste d'association nous n'aurons pas d'information
  sur la syntaxe de celle ci (type des operandes et nombre d'arguments). Cependant cette information sera obtenue ici
  grâce au type de l'étiquette qui nous indique la syntaxe. Ce choix sera critiqué dans la section \todo{mettre ref partie encode}}

%%-----------lookup et lookdown------
\subsection{Fonctions de recherche}

Il est désormais question de réaliser deux fonctions permettant la recherche
au sein d'une liste d'association tel que celle définie dans la section précédente
\ref{Structure de donnee}.

\codefrom{src}{association_list}{lookup}

Encore une fois l'utilisation de la monade option est indispensable ici car
on ne peut pas garantir que pour une liste donnée nous trouverons l'entier
qui lui est associé. Notre travail sera de démontrer que cette fonction n'échoue pas
sur une liste contenant l'ensemble des associations. Nous y reviendrons dans la section
\ref{Lemmeslol}
Voici la fonction effectuant la recherche dans le sens inverse en suivant le même principe:

\codefrom{src}{association_list}{lookdown}



%%----------Lemmes----------
\subsection{Lemmes}
\label{Lemmeslol}

Avant de commencer toute preuve il nous faut définir de manière statique une liste
contenant l'ensemble des associations entre les ``tag'' \todo{encore typo} et leur entier naturel associé.


\codefrom{src}{association_list}{encdec}
.....\\ \todo{faire un peut plus jolie avec les 3 petits points}

Tous les théorèmes que nous définirons se baserons sur la liste ``encdec''\todo{typo}. \\
Nous avons besoin de vérifier que la liste contient bien l'ensemble des associations,
il existe deux manière de faire. Une première façon qui consiste à faire une analyse de cas
au sein de la preuve sur le type tag.
Une autre méthode consiste à vérifier de façon calculatoire cette propriété, puis de montrer
une équivalence entre ce calcul et sa proposition associée. 
Cette opération en Coq peut être réaliser avec l'aide du type ``reflect'':

\codefrom{rapport}{definitions}{reflect}

Pour mieux comprendre en quoi ce type va nous être utile, il faut comprendre son utilisation.
Le type ``reflect'' est composé de deux constructeurs, si l'on possède un élément de type
``reflect P true'' alors cela signifie que notre élément est le constructeur ``ReflectT''
et celui ci possède une preuve du prédicat ``P''. Le raisonement est le même pour ``reflect P false''
sauf que dans ce cas on pourra obtenir une preuve de non ``P''. Pour vulgariser ce
principe on peut dire que avoir une preuve de ``reflect P b'' implique que la preuve
de P est équivalente à ``b = true''. Ce principe est illustré par le théorème suivant:

\codefrom{rapport}{definitions}{reflect_iff}


Mettons de côté le type ``reflect'' et définissons maintenant une fonction
pour vérifier calculatoirement un prédicat sur l'ensemble des tags:

\codefrom{src}{association_list}{forall_tag}

L'ensemble des fonctions ``forall\_tag\_...'' suivent le même schéma que la fonction suivante:

\codefrom{src}{association_list}{forall_tag_uno}

Tout comme nous l'avions fait lorsque nous avions définie la fonction d'égalité sur les tags \ref{LemmesAST},
nous souhaitons pouvoir passer du monde calculatoire au monde propositionnel:

\codefrom{src}{association_list}{helpBefore1}
\codefrom{src}{association_list}{helpBefore2}

Afin de définir des prédicats pour la fonction ``forall\_tag'' il nous faut définir un
équivalent au connecteur propositionnel \todo{mettre le symbole implication} :

\codefrom{src}{association_list}{imply}

L'obectif final de cette section est de démontrer les théorèmes suivant (dont la structure est analogue aux lemmes prouver
en dans la section précédente \todo{mettre la ref}):

\codefrom{src}{association_list}{lookup_lookdown}
\codefrom{src}{association_list}{lookdown_lookup}


Si nous souhaitons utiliser la reflection il nous faut définir des fonctions refletant
ces théorèmes dans l'ensemble des booléens. La fonction pour le théorème ``lookup\_lookdown''
est la suivante:

\codefrom{src}{association_list}{lookup_encdec}
``eq\_mtag'' et ``eq\_mtag'' sont simplement des fonctions d'égalité sur les types ``option tag'' et ``option nat''.
L'intérêt d'avoir utiliser reflect pour réaliser nos preuves peut se voir immédiatement quand à la taille
du script de preuve du théorème ``lookup\_lookdown'' que voici:

\codefrom{src}{association_list}{lookup_lookdown}

\codefrom{src}{association_list}{lookup_lookdown_script}

Certains lemmes ont ici été passés volontairement sous silence car l'objectif n'est pas
de comprendre reflect dans les moindres détails mais simplement de comprendre son itérêt.

\todo{peut etre conclure}


%%------------------------Encode Decode----------------------
\section{Encode Decode}

\todo{une petite phrase qui dit que le type des tag lors du decode nous permet de savoir ce que l'on doit faire exactement}
\todo{introduction peut etre parler à l'avance du problème d'avoir utiliser un truc bien exhaustif}



%%---------Fcts prélminaires -------
\subsection{Fonctions prélminiaires}

Afin de réaliser les fonctions d'encodage et de décodage de nos instructions il nous manque encore quelques operations.
Les premières fonctions que nous allons définir deux fonctions permettant de transformer une operande en liste de booleens.

\codefrom{src}{encode}{operand_to_bin}

De façon similaire il nous faut aussi une fonction permettant d'encoder des operandes lorsque celle ci seront utiliseé dans
les instructions à 2 operandes c'est à dire que celle ci aura une taille de 16 \todo{refaire cette phrase}

\codefrom{src}{encode}{operand_to_bin_double}

Définisson quelques lemmes sur ces nouvelles fonctions.
\codefrom{src}{encode}{operand_to_bin_hypothesis_reg}
\codefrom{src}{encode}{operand_to_bin_hypothesis_imm}
\codefrom{src}{encode}{operand_to_bin_size}
\todo{peut etre commenter un peu plus ce genre de choses}


Pour la fonction de décodage nous aurons besoin d'une fonction permettant de découper
une liste de booléens en plusieurs sous listes. Voici la fonction qui effectura cette operation:

\codefrom{src}{encode}{get_first_n_bit}

La fonction retourne un couple de deux listes, la première correspond aux ``size'' premiers
bits de la liste et la seconde au reste  de la liste. Le fait de retourner le reste de la liste
nous permettra de découper celle ci à nouveau.
\todo{relire ici}




%%-----------Encode--------
\subsection{Encode}

\todo{phrase d'intro}

\subsubsection{Monade bind}

La fonction encode utilise les fonctions que nous avons définies dans les sections précédentes qui sont généralements
des fonctions partiels. Lorsque l'on souhaite utiliser leur valeur de retour nous somme obliger de faire un
filtrage de la forme :

\codefrom{rapport}{definitions}{pattern_matching}

Cette construction est très lourde dans la définition des fonctions nous allons donc crée une monade
afin de faciliter l'utilisation de ces fonctions partielles:

\codefrom{src}{encode}{monade}

Nous avons maintenant une fonction bind qui nous permet d'automatiser ce filtrage. Coq nous permet de
définir de nouvelles notations \todo{je suis pas sur du traits}

\codefrom{src}{encode}{notation}






%%--------Encode decode-----
\subsection{Implementation des fonctions Encode et Decode}

Commençons par la définition de la fonction encode. D'après le type instruction \todo{mettre la ref}
chaque instruction s'encode différement, nous allons devoir définir une fonction comme celle ci
pour chaque type d'instruction:

\codefrom{src}{encode}{encode_t_n}

Ce qui nous permet de définir la fonction encode suivante:

\codefrom{src}{encode}{encode}

La fonction de décodage quant à elle n'est pas composée de plusieurs fonctions car l'entrée
étant une liste de booléens.
Voici une version partielle du code de decode:

\codefrom{src}{encode}{decode}

Ici la définition que nous avons utilisée pour les tags s'avère utile car elle nous permet
une fois récupérer dans la liste d'association de déterminer immédiatement quel type
d'instruction il nous faut crée.





%%----Lemmes----------
\subsection{Lemmes}

De même que pour la définition d'encode \todo{mettre la ref} nous allons diviser le travail pour chaque
type d'instructions.

\codefrom{src}{encodeProof}{encode_decode_t_n}

Le problème de la représentation actuelle des données fait que nous somme obliger de réaliser une preuve
similaire mais non triviale pour chaque type d'instruction. Cela crée énormément de redondance dans les preuves
et cela n'est jamais bon signe. Nous verrons dans la partie future work \todo{faire la ref} les solutions envisageables afin
de surmonter ce problème.
Cela nous permet finalement d'obtenir la preuve qu'une instruction encoder par notre assembleur puis decoder par celui
ci est identique. On a donc une preuve que la syntaxe est belle et bien préservée.

Définissons le théorème opposée à celui ci à savoir :

\codefrom{src}{encodeProof}{decode_encode}

Tout comme pour la preuve d'encode ici nous devons effectuer la preuve pour chaque type d'instructions
ce qui rend une nouvelle fois la preuve très verbeuse et redondante. 




%%-------Theoremes finaux------
\subsection{Theorèmes finaux}

A l'heure actuelle nous avons une preuve que notre assembleur produit bien \todo{finir cette phrase}
pour une seul instruction. Cependant un assembleur complet travail sur un ensemble d'instructions
ou bien un flux de bits. Dans notre cas nous allons définir une fonction décodant une liste d'instructions et qui
retourneras une liste de booléens de taille ``32 * length(liste\_instructions)''\todo{typo}.
Pour ce faire il nous faut une fonction préalable :

\codefrom{src}{encode}{concat_listes_32}

A noter le test sur la taille de la liste
qui nous permettra d'obtenir une hypothèse supplémentaire lors de nos preuves.
Etant donné que la fonction encode utilise la monade option nous somme obliger de définir une fonction
traverse permettant de transformer une liste de type ``list (option A)'' en une liste de type ``list A''.

\codefrom{src}{encode}{traverse}

Voici la définition de la fonction encodant une liste d'insruction (pour la lisibilité celle ci est
divisée en 3 fonctions)

\codefrom{src}{encode}{encode_flux}

Passons maintenant au décodage d'un flux de booléens. Tout comme pour l'encodage il nous faut
une fonction préliminaire. Cette fois ci nous avons besoin de découper la liste de booléens
en entrée en sous listes de taille 32, ce qui nous amène à la définition suivante:

\codefrom{src}{encode}{cut_32}

Nous pouvons maintenant définir la fonction permettant de transformer un flux de booléens
en une liste d'instruction:

\codefrom{src}{encode}{decode_flux}



Nous pouvons maintenant définir les théorèmes finaux de notre assembleur qui sont les suivants:

\codefrom{src}{encode}{encode_decode_flux_decoup}

\codefrom{src}{encode}{decode_flux_decoup_encode}

\remark{Prouver ces deux théorèmes nécéssite un travail assez conséquent au niveau des fonctions
  de découpage. Cependant ces preuves restant dans la même veine que celles que nous avons déja
  vues précédement leur explication ne semble pas justifiée}
\todo{regarder quand meme y en as peut etre une bien}






\section{Conclusion}




\end{document}
               

\todo{Parler du fait que c'est très exhaustif et que ça marche pour MMIX mais que ça va pas marcher pour le reste}

\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
  {->}{{${\to}$}}2
  {*}{{${\times}$}}1
  {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.v}}

\newcommand{\codefromOcaml}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}
           
%% ** Theorem styles 
           
           
\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\question}[1]{\textcolor{green}{#1}}
\newcommand{\etc}{\textit{etc.}}

\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}
               
\newcommand{\fun}[1]{\lstinline!#1!}
%% ** Title

\title{Assembleur x86 certifié}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 

\vfill
\setcounter{tocdepth}{2}
\tableofcontents
\vfill


\section{Introduction}

\todo{parler du fait que le but pour les assembleurs que l'on va définir est d'avoir une preuve dans les deux sens
  que l'encodage et le decodage préserve l'instruction (a bien rédiger haha)}


%%--------------------------------------MMIX et représentation des données-----------------
\section{MMIX et représentation des données}
\label{partieMMIX}

\todo{finir cette introduction}
Le langage d'assembleur MMIX à été crée par Donald Knuth en 1999.
Pour l'instant il n'existe aucune implémentation concrète de MMIX il
à été crée et utilisée dans un but pédagogique.







%%-------------Definition---------------
\subsection{Définition MMIX}

Dans cette section il sera question de définir la syntaxe des instructions MMIX.
MMIX est un jeu d'instruction RISK ce qui signifie que la taille des instructions
est fixer. Ici une instruction est de taille 32 dont voici le découpage.

\begin{tabular}{|c|c|c|c|}
  \hline
  Etiquette & Operande 1 & Operande 2 & Operande 3\\
  \hline
  0-7 bits & 8-15 bits & 16-23 bits & 24-31  \\
  \hline
  TAG & X & Y & Z \\
  \hline
\end{tabular}
\remark{La dernière ligne du tableau permet simplement d'associer à chaque partie
  de l'instruction un nom de variable afin d'alléger le texte dans la suite du rapport}
%il est le successeur du langage MIX également conçu par donald Knuth 8 ans plus tot
Les operandes peuvent être à la foix un immediat ou un registre.
Ici on ne s'attarde pas sur la sémantique des instructions ce qui nous intérresse
est la syntaxe. Une des spécificité de la syntaxe est la possibilité d'obtenir des operandes
de plus grande taille avec les formes d'instructions suivantes:\\
\begin{tabular}{|c|c|c|}
  \hline 
  TAG & X & YZ \\
  \hline
\end{tabular}

\begin{tabular}{|c|c|}
  \hline 
  TAG & XYZ \\
  \hline
\end{tabular}





%%-------------Representation---------------
\subsection{Représentation des données}
\label{representation des donnees}
\todo{faire une phrase d'intro}

Une représentation intuitive des operandes serait de les déclarer de la manière suivante,


Afin de faciliter les preuves pour faire un premier travail en hauteur, j'ai jugé nécéssaire
d'éclater le type de donnée afin de ne pas surchager les informations nécéssaires dans la liste d'association
mais nous reviendrons sur ce choix dans la partie \ref{partieOpcode}.
Le choix à été de stocker l'information dès les étiquettes de la forme

\todo{Parler du fait que c'est très exhaustif et que ça marche pour MMIX mais que ça va pas marcher pour le reste}
\codefrom{src}{ast_instructions}{tag}
%% \codefrom{src}{ast_instructions}{tag_definition}


Ces différents types d'étiquettes vont nous permettre dans les définitions des instructions de les définir
de crée un type d'étiquette par syntaxe. Dans le cas de MMIX ce n'est pas très génant étant donné que le
nombre de combinaison est assez faible.
\remark{Pour un langage assembleur tel que x86 il ne sera pas possible de definir les instructions de façon exhaustive il faudra
  utiliser une autre représentation des données. Nous en reparlerons dans la partie \todo{mettre la ref}}

Maintenant nous voulons définir un type de donnée qui puisse représenter une instruction.
Etant donné que nous avons dissocié les différents types de tag en fonction de la syntaxe de l'instruction
nous allons poursuivre de la même manière en définissant des types pour chaque type d'instructions.
En voici un exemple pour les instructions avec 3 opérandes représentants des registres.
\codefrom{src}{ast_instructions}{instruction_tern_n}
\remark{Le record ici est approprié étant donné que l'on souhaite que l'ensemble des champs soient
  définis dans une instruction pour ne pas laisser de champs vides (ce qui n'aurait pas de sens au
  niveau syntaxique}

Nous obtenons donc le type suivant pour les instructions:
\codefrom{src}{ast_instructions}{instruction}






%%-------------Egalité---------------
\subsection{Egalité entre deux éléments d'un type de donnée}
Avant de passer à la section suivante attardons nous sur l'égalité de deux éléments de même type.
Si l'on souhaite définir une égalité le type de donnée suivant :
\codefrom{rapport}{definitions}{example_type}
\remark{Nous nous attarderons ici sur les types inductifs uniquement}

Il va nous falloir crée une fonction exhaustive énumérant l'ensemble des cas pour determiner
si les deux élements sont égaux ou non. Ce qui nous donne pour l'exemple précédent la fonction suivante:

\codefrom{rapport}{definitions}{equal}

Ce genre de fonctions sont très fastidieuses à rédiger et l'on constate déja la taille de celle ci
pour un type de donnée composé de deux éléments.
Si nous souhaitions écrire cette fonction le type ``tag'' \todo{peut etre changer la police} dans
la section \ref{representation des donnees} la perte de temps serait considérable.
Dans Coq il existe une commande qui va nous permettre de générer cette fonction
automatiquement, la voici:

\codefrom{rapport}{definitions}{SchemeEqual}



%%-------------Lemmes---------------
\subsection{Lemmes}
Voici un premier lemme qui nous sera très utile par la suite:
\codefrom{src}{ast_instructions}{tag_beq_different}
Ici on désire montrer que si l'on montre que deux étiquettes sont équivalentes
à l'aide de notre fonction sur les booléens alors on peut obtenir une preuve
de cette égalité dans le monde propositionnel.












%%----------------------------------------Section Conversion N liste B -----------------------------
\section{Conversion N liste B}

\todo{faire une petite intro la dessus}


%------------repres bits ----------------
\subsection{Représentation des bits}
\todo{Enfaite il faut parler de suite de bits (enfin c'est pas le bon mot) mais pas de bits tout court}

Dans la section \ref{representation des donnees} nous avons parlé de la représentation des instructions
sous forme \todo{trouver le mot}. Maintenant il nous faut choisir un type de donnée pour représenter
les instructions sous forme binaires.
Notre type de donnée doit pouvoir nous permettre de :
\begin{enumerate}
\item Pouvoir recevoir une chaine de bits de taille n quelconque et multiple de 32 de tel sorte que
  lors d'un parsing d'un fichier binaire il n'y ai pas de traitement supplémentaire à faire.
\item Il doit être simple car il est préférable que les preuves qui sont le coeur de ce projet restent
  plus aisées à mettre en place.
\end{enumerate}

Il existe dans la librairie standard de Coq une représentation binaire pour les entiers naturels.
Le problème de celle ci est que l'on ne peut pas représenter un entier naturel sur un nombre de bits différents
que celui nécéssaire à son encodage. Nous ne pouvons pas nous permettre d'avoir une taille variable en
fonction de la valeur encodée et cela contredirait le premier pré-requis que nous souhaitons.

La structure de donnée par excellence qui satisfait l'ensemble de nos prérequis est la liste.
En effet elle permet de répondre à ces deux besoins, nous utiliserons donc des listes de booléens.
\todo{je vais quand même pas dire que false c'est 0 et true c'est 1 non? :p}

\codefrom{src}{ast_instructions}{binary_instruction}




%-------------Fcts de conversion --------------
\subsection{Fonctions de conversion}
\label{Fonctions de conversion}
Maintenant que nous avons fixé une représentation pour nos suite de bits, commençons par définir
une fonction de conversion d'une liste de booléens vers un entier naturel:

\codefrom{src}{binary}{bitn}

Commençons par prêtter attention à cette fonction car elle est une simple implémentation
d'une formule bien connue pour determiner la valeur d'un nombre sous forme binaire
en forme décimal. Passons maintenant à la fonction effectuant l'opération inverse:

\codefrom{src}{binary}{nbit}


Ici cette fonction possède plusieurs subtilités d'implémentation dues à des restrictions du
à une restriction du langage Coq.

La première chose que l'on peut remarquer se situe au niveau des arguments de
la fonction. En effet nous souhaitons simplement encoder un entier naturel vers
une liste de booléens et pourtant nous avons deux arguments.
En réalité nous souhaiterions pouvoir écrire notre fonction comme ceci
(implémentation en Ocaml):
\codefromOcaml{rapport}{example}{nbit}

Cependant cette implémentation est impossible avec Coq car celui ci utilise
des opérateurs de points fixes \todo{lol j'ai pas tout compris à ce truc je suis
  pas sur de ce que je met} et dans ce dernier exemple l'appel récursif ne s'éffectue
pas avec le prédécesseur de ``k'' \todo{again comment citer une var} mais avec le
résultat de ``k'' par deux. \todo{finir ça et trouver la vraie justification tranquillement}
\todo{Placer les ensembles finis (enfin c'est pas le mot exacte)}


\remark{Dans notre cas cette fonction nous convient parfaitement car nous souhaitons
  obtenir une liste de booléens de taille determinée. Cependant cela nous permet d'illustrer
  la façon dont Coq définie la récursion}

\todo{enfaite ça va être la seconde (changer puis supprimer)}
On pourra aussi noter le type de retour de la fonction.
On utilise une monade bien connue des programmeurs fonctionnels au travers du type
``option'' \todo{faut que je retrouve comment faire les quotes}. Cela nous permet de
dire que la fonction peut échouer sans pour autant devoir renvoyer une valeur par
défaut où lever une exception. Ici le cas ou la fonction peut échouer est lorsque
l'entier naturel que l'on souhaite encoder nécéssite plus de bits que l'entier n alors
on ne peut pas réaliser la transformation.





%%--------------Lemmes-----------
\subsection{Lemmes}

Il nous faut maintenant nous demander quelles sont les propriétées qui nous intérressent sur
les deux fonctions que nous venons de définir dans la section \ref{Fonctions de conversion}.

Une propriété qui s'avèrera surement utile par la suite est le Lemme suivant:

En effet cela nous permettra de vérifier qu'une instruction produite par les fonctions
des sections suivantes \todo{mettre la ref} produisent bien des instructions de taille 32.

\codefrom{src}{binary}{size_n_bit}

Une des information importante à retenir de ce théorème est sa structure.
En effet comme nous avons vus précédement \ref{Fonctions de conversion} la
fonction n\_bit peut échouer, il nous faut donc vérifier cette propriété
uniquement lorsque celle ci termine correctement. C'est pour cette raison
que nous devons utiliser l'implication pour ne considérer que ces cas précis. \\

Il est maintenant question de définir les deux théorèmes les plus important de
cette section. Notre but pour l'ensemble des fonctions que l'on définis est de
montrer qu'elles sont \todo{trouver le mot ici (c'est pas symétriques mais un truc dans le genre)}
car elles seront utilisé dans l'encodage et decodage des instructions \todo{mettre la ref}
Voici donc le premier théorème que nous voulons prouver:

\codefrom{src}{binary}{nbitn}

Comme pour le lemme précédent ce théorème suit la même structure d'implication en raison des effets
de bords induit par la monade option.
Pour le théorème suivant nous avons besoin d'émettre une hypothèse supplémentaire sur l'argument
``n'' \todo{encore les vars}. Si nous n'effectuons pas cette assertion supplémentaire le
théorème n'a pas de sens et n'est pas conséquent pas prouvable.

\codefrom{src}{binary}{bitnbit}

\todo{la phrase suivante est nul mais pourquoi pas mettre une petite phrase de conclusion de la partie}
Nous avons en notre possession l'ensemble des théorèmes nécéssaires pour la suite de nos preuves




%%---------------------------Conversion Opcode list B---------------------------
\section{Conversion Opcode liste B}
\label{partieOpcode}

\todo{faire une phrase d'intro de ça}


%%---------Structure de donnée----------------
\subsection{Structure de donnée}
\label{Structure de donnee}
La première étape d'encodage ou de décodage d'une instruction se situe
au niveau de l'étiquette. Dans le cas de MMIX comme vus en section \ref{partieMMIX}
une étiquette est associée à un unique opcode. Une façon de stocker cette
correspondance est d'utilisé des paires.
\codefrom{src}{association_list}{assoc}

Nous avons maintenant une représentation pour les associations il nous faut
maintenant stocker l'ensemble de celles ci. Etant donné que le nombre
d'instructions est de 256 utilisé une représentation sous forme
de liste est envisageable. Un argument supplémentaire est que la liste
est un type inductif qui nous permettra de raisonner plus aisement
lors des preuves étant donné sa relative simplicité. En effet on pourrait utiliser
un dictionnaire pour réduire la complexité, cependant l'utilisation de ce genre
de type de donnée rendrais les preuves plus complexes \todo{pas sur au final :p}.
Nous obtenons donc le type suivant pour représenté notre collection d'associations:

\codefrom{src}{association_list}{tag_opcode_assoc}

\remark{Un autre argument en faveur de l'utilisation des listes à l'instard des
  dictionnaires est le fait que cette liste sera définie une unique fois et pourra être utiliser
  pour effectuer les deux sens de la correspondance.
}

\todo{peut etre placer une remarque sur le fait que on stocke un nat et pas directement
  la liste de booleen qui correspond}
\todo{C'est même sur qu'il va falloir en parler de ça}


\todo{faire un paragraphe de pk il faut pas nécéssairement plus d'informations dans la liste
  d'association avec notre représentation des données ``c'est maintenant que le fait d'avoir tout mis a plat prend son sens
étant donné que notre liste d'association est très simple ce qui nous permet de faciliter les preuves sur celles ci}


%%-----------lookup et lookdown------
\subsection{Fonctions de recherche}

Il est désormais question de réaliser deux fonctions permettant la recherche
au sein d'une liste d'association tel que celle définie dans la section précédente
\ref{Structure de donnee}.

\codefrom{src}{association_list}{lookup}

Encore une fois l'utilisation de la monade option est indispensable ici car
on ne peut pas garantir que pour une liste donnée nous trouverons l'entier
qui lui est associé. Notre travail sera de démontrer que cette fonction n'échoue pas
sur une liste contenant l'ensemble des associations. Nous y reviendrons dans la section
\todo{mettre la ref}.
Voici la fonction effectuant la recherche inverse en suivant le même principe:

\codefrom{src}{association_list}{lookdown}

\todo{peut etre conclure}




%%----------Lemmes----------
\subsection{Lemmes}

Avant de commencer toute preuve il nous faut définir de manière statique une liste
contenant l'ensemble des associations entre les ``tag'' \todo{encore typo} et leur entier naturel associé.

\todo{faire cet import et faire un truc sympas pour montrer que les premières lignes}
\codefrom{src}{association_list}{lol}

Tous les théorèmes que nous définirons se baserons sur cette liste ``encdec''\todo{typo}. \\
Nous somme ici face à un problème car pour vérifier que la liste contient bien l'ensemble des
associations nécéssaires le seul moyens de le faire est de calculer dynamiquement cela.
Mais nous avons besoin de cette propriété afin de pouvoir réaliser nos futures preuves.
Il va nous falloir introduire un nouveau méchanisme permettant à partir d'un résultat obtenue
par calcul d'obtenir une proposition traduisant ce résultat dans le monde des propositions.
\todo{peut être améliorer la phrase précédente}.
Cette opération en Coq peut être réaliser avec l'aide du type ``reflect'':

\codefrom{src}{association_list}{reflect}

Pour mieux comprendre en quoi ce type va nous être utile, il faut comprendre son utilisation.
Le type ``reflect'' est composé de deux constructeurs, si l'on possède un élément de type
``reflect P true'' alors cela signifie que notre élément est le constructeur ``ReflectT''
et celui ci possède une preuve du prédicat ``P''. Le raisonement est le même pour ``reflect P false''
sauf que dans ce cas on pourra obtenir une preuve de non ``P''. Pour vulgariser ce
principe on peut dire que avoir une preuve de ``reflect P b'' implique que la preuve
de P est équivalente à ``b = true''. Ce principe est illustré par le théorème suivant:

\codefrom{rapport}{definitions}{reflect_iff}


Mettons de côté le type ``reflect'' et définissons maintenant un ensemble de
fonctions permettant de vérifier une propriété sur l'ensemble de nos tag.
Il nous faut donc définir des fonctions comme celles ci pour chaque sous type de tag: \todo{sous type ça fait ambigu}

\codefrom{src}{association_list}{forall_tag_uno}

Pour obtenir la fonction suivante:

\codefrom{src}{association_list}{forall_tag}

Grâce à ces fonctions nous allons pouvoir vérifier si un prédicat est vraie pour l'ensemble des tag
de notre language. \\

Nous allons maintenant prouver un premier théorème:
\codefrom{src}{association_list}{forall_tagP}

Ce théorème est très intérressant (même si en l'état il n'est pas très utile) car il nous permet
d'affimer au travers de reflect de passer du monde des propositions ``(forall (t : tag), reflect (P t) (f t))''
à celui du calcul avec notre fonction ``forall\_tag'' ``reflect (forall t, P t) (forall\_tag f)''.
Pour prouver ce théorème il nous faut deux théorème préliminaires permettant
\todo{parler des théorèmes help mais enfaite c'est un des help qui fait ce que je dis au dessus}


\todo{motiver le imply proprement}

\codefrom{src}{association_list}{implyP}

\todo{finir cette partie à tranquille demain}


%%------------------------Encode Decode----------------------
\section{Encode Decode}

\todo{une petite phrase qui dit que le type des tag lors du decode nous permet de savoir ce que l'on doit faire exactement}
\todo{introduction peut etre parler à l'avance du problème d'avoir utiliser un truc bien exhaustif}



%%---------Fcts prélminaires -------
\subsection{Fonctions prélminiaires}

Afin de réaliser les fonctions d'encodage et de décodage de nos instructions il nous manque encore quelques operations.
Les premières fonctions que nous allons définir deux fonctions permettant de transformer une operande en liste de booleens.

\codefrom{src}{encode}{operand_to_bin}

De façon similaire il nous faut aussi une fonction permettant d'encoder des operandes lorsque celle ci seront utiliseé dans
les instructions à 2 operandes c'est à dire que celle ci aura une taille de 16 \todo{refaire cette phrase}

\codefrom{src}{encode}{operand_to_bin_double}

Définisson quelques lemmes sur ces nouvelles fonctions.
\codefrom{src}{encode}{operand_to_bin_hypothesis_reg}
\codefrom{src}{encode}{operand_to_bin_hypothesis_imm}
\codefrom{src}{encode}{operand_to_bin_size}
\todo{peut etre commenter un peu plus ce genre de choses}


Pour la fonction de décodage nous aurons besoin d'une fonction permettant de découper
une liste de booléens en plusieurs sous listes. Voici la fonction qui effectura cette operation:

\codefrom{src}{encode}{get_first_n_bit}

La fonction retourne un couple de deux listes, la première correspond aux ``size'' premiers
bits de la liste et la seconde au reste  de la liste. Le fait de retourner le reste de la liste
nous permettra de découper celle ci à nouveau.
\todo{relire ici}




%%-----------Encode--------
\subsection{Encode}

\todo{phrase d'intro}

\subsubsection{Monade bind}

La fonction encode utilise les fonctions que nous avons définies dans les sections précédentes qui sont généralements
des fonctions partiels. Lorsque l'on souhaite utiliser leur valeur de retour nous somme obliger de faire un
filtrage de la forme :

\codefrom{rapport}{definitions}{pattern_matching}

Cette construction est très lourde dans la définition des fonctions nous allons donc crée une monade
afin de faciliter l'utilisation de ces fonctions partielles:

\codefrom{src}{encode}{monade}

Nous avons maintenant une fonction bind qui nous permet d'automatiser ce filtrage. Coq nous permet de
définir de nouvelles notations \todo{je suis pas sur du traits}

\codefrom{src}{encode}{notation}






%%--------Encode decode-----
\subsection{Implementation des fonctions Encode et Decode}

Commençons par la définition de la fonction encode. D'après le type instruction \todo{mettre la ref}
chaque instruction s'encode différement, nous allons devoir définir une fonction comme celle ci
pour chaque type d'instruction:

\codefrom{src}{encode}{encode_t_n}

Ce qui nous permet de définir la fonction encode suivante:

\codefrom{src}{encode}{encode}

La fonction de décodage quant à elle n'est pas composée de plusieurs fonctions car l'entrée
étant une liste de booléens.
Voici une version partielle du code de decode:

\codefrom{src}{encode}{decode}

Ici la définition que nous avons utilisée pour les tags s'avère utile car elle nous permet
une fois récupérer dans la liste d'association de déterminer immédiatement quel type
d'instruction il nous faut crée.





%%----Lemmes----------
\subsection{Lemmes}

De même que pour la définition d'encode \todo{mettre la ref} nous allons diviser le travail pour chaque
type d'instructions.

\codefrom{src}{encodeProof}{encode_decode_t_n}

Le problème de la représentation actuelle des données fait que nous somme obliger de réaliser une preuve
similaire mais non triviale pour chaque type d'instruction. Cela crée énormément de redondance dans les preuves
et cela n'est jamais bon signe. Nous verrons dans la partie future work \todo{faire la ref} les solutions envisageables afin
de surmonter ce problème.
Cela nous permet finalement d'obtenir la preuve qu'une instruction encoder par notre assembleur puis decoder par celui
ci est identique. On a donc une preuve que la syntaxe est belle et bien préservée.

Définissons le théorème opposée à celui ci à savoir :

\codefrom{src}{encodeProof}{decode_encode}

Tout comme pour la preuve d'encode ici nous devons effectuer la preuve pour chaque type d'instructions
ce qui rend une nouvelle fois la preuve très verbeuse et redondante. 




%%-------Theoremes finaux------
\subsection{Theorèmes finaux}

A l'heure actuelle nous avons une preuve que notre assembleur produit bien \todo{finir cette phrase}
pour une seul instruction. Cependant un assembleur complet travail sur un ensemble d'instructions
ou bien un flux de bits. Dans notre cas nous allons définir une fonction décodant une liste d'instructions et qui
retourneras une liste de booléens de taille ``32 * length(liste\_instructions)''\todo{typo}.
Pour ce faire il nous faut une fonction préalable :

\codefrom{src}{encode}{concat_listes_32}

A noter le test sur la taille de la liste
qui nous permettra d'obtenir une hypothèse supplémentaire lors de nos preuves.
Etant donné que la fonction encode utilise la monade option nous somme obliger de définir une fonction
traverse permettant de transformer une liste de type ``list (option A)'' en une liste de type ``list A''.

\codefrom{src}{encode}{traverse}

Voici la définition de la fonction encodant une liste d'insruction (pour la lisibilité celle ci est
divisée en 3 fonctions)

\codefrom{src}{encode}{encode_flux}

Passons maintenant au décodage d'un flux de booléens. Tout comme pour l'encodage il nous faut
une fonction préliminaire. Cette fois ci nous avons besoin de découper la liste de booléens
en entrée en sous listes de taille 32, ce qui nous amène à la définition suivante:

\codefrom{src}{encode}{cut_32}

Nous pouvons maintenant définir la fonction permettant de transformer un flux de booléens
en une liste d'instruction:

\codefrom{src}{encode}{decode_flux}



Nous pouvons maintenant définir les théorèmes finaux de notre assembleur qui sont les suivants:

\codefrom{src}{encode}{encode_decode_flux_decoup}

\codefrom{src}{encode}{decode_flux_decoup_encode}

\remark{Prouver ces deux théorèmes nécéssite un travail assez conséquent au niveau des fonctions
  de découpage. Cependant ces preuves restant dans la même veine que celles que nous avons déja
  vues précédement leur explication ne semble pas justifiée}
\todo{regarder quand meme y en as peut etre une bien}



\section{Conclusion}

\end{document}
               


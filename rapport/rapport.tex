\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
  {->}{{${\to}$}}2
  {*}{{${\times}$}}1
  {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.v}}
           
%% ** Theorem styles 
           
           
\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\question}[1]{\textcolor{green}{#1}}
\newcommand{\etc}{\textit{etc.}}

\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}
               
\newcommand{\fun}[1]{\lstinline!#1!}
%% ** Title

\title{Assembleur x86 certifié}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 

\vfill
\setcounter{tocdepth}{2}
\tableofcontents
\vfill


\section{Introduction}




%%--------------------------------------MMIX et représentation des données-----------------
\section{MMIX et représentation des données}
\label{partieMMIX}

\todo{finir cette introduction}
Le langage d'assembleur MMIX à été crée par Donald Knuth en 1999.
Pour l'instant il n'existe aucune implémentation concrète de MMIX il
à été crée et utilisée dans un but pédagogique.







%%-------------Definition---------------
\subsection{Définition MMIX}

Dans cette section il sera question de définir la syntaxe des instructions MMIX.
MMIX est un jeu d'instruction RISK ce qui signifie que la taille des instructions
est fixer. Ici une instruction est de taille 32 dont voici le découpage.

\begin{tabular}{|c|c|c|c|}
  \hline
  Etiquette & Operande 1 & Operande 2 & Operande 3\\
  \hline
  0-7 bits & 8-15 bits & 16-23 bits & 24-31  \\
  \hline
  TAG & X & Y & Z \\
  \hline
\end{tabular}
\remark{La dernière ligne du tableau permet simplement d'associer à chaque partie
  de l'instruction un nom de variable afin d'alléger le texte dans la suite du rapport}
%il est le successeur du langage MIX également conçu par donald Knuth 8 ans plus tot
Les operandes peuvent être à la foix un immediat ou un registre.
Ici on ne s'attarde pas sur la sémantique des instructions ce qui nous intérresse
est la syntaxe. Une des spécificité de la syntaxe est la possibilité d'obtenir des operandes
de plus grande taille avec les formes d'instructions suivantes:\\
\begin{tabular}{|c|c|c|}
  \hline 
  TAG & X & YZ \\
  \hline
\end{tabular}

\begin{tabular}{|c|c|}
  \hline 
  TAG & XYZ \\
  \hline
\end{tabular}





%%-------------Representation---------------
\subsection{Représentation des données}
\label{representation des donnees}
\todo{faire une phrase d'intro}

Une représentation intuitive des operandes serait de les déclarer de la manière suivante,


Afin de faciliter les preuves pour faire un premier travail en hauteur, j'ai jugé nécéssaire
d'éclater le type de donnée afin de ne pas surchager les informations nécéssaires dans la liste d'association
mais nous reviendrons sur ce choix dans la partie \ref{partieOpcode}.
Le choix à été de stocker l'information dès les étiquettes de la forme

\todo{Parler du fait que c'est très exhaustif et que ça marche pour MMIX mais que ça va pas marcher pour le reste}
\codefrom{src}{ast_instructions}{tag}
%% \codefrom{src}{ast_instructions}{tag_definition}


Ces différents types d'étiquettes vont nous permettre dans les définitions des instructions de les définir
de crée un type d'étiquette par syntaxe. Dans le cas de MMIX ce n'est pas très génant étant donné que le
nombre de combinaison est assez faible.
\remark{Pour un langage assembleur tel que x86 il ne sera pas possible de definir les instructions de façon exhaustive il faudra
  utiliser une autre représentation des données. Nous en reparlerons dans la partie \todo{mettre la ref}}

Maintenant nous voulons définir un type de donnée qui puisse représenter une instruction.
Etant donné que nous avons dissocié les différents types de tag en fonction de la syntaxe de l'instruction
nous allons poursuivre de la même manière en définissant des types pour chaque type d'instructions.
En voici un exemple pour les instructions avec 3 opérandes représentants des registres.
\codefrom{src}{ast_instructions}{instruction_tern_n}
\remark{Le record ici est approprié étant donné que l'on souhaite que l'ensemble des champs soient
  définis dans une instruction pour ne pas laisser de champs vides (ce qui n'aurait pas de sens au
  niveau syntaxique}

Nous obtenons donc le type suivant pour les instructions:
\codefrom{src}{ast_instructions}{instruction}






%%-------------Egalité---------------
\subsection{Egalité entre deux éléments d'un type de donnée}
Avant de passer à la section suivante attardons nous sur l'égalité de deux éléments de même type.
Si l'on souhaite définir une égalité le type de donnée suivant :
\codefrom{rapport}{definitions}{example_type}
\remark{Nous nous attarderons ici sur les types inductifs uniquement}

Il va nous falloir crée une fonction exhaustive énumérant l'ensemble des cas pour determiner
si les deux élements sont égaux ou non. Ce qui nous donne pour l'exemple précédent la fonction suivante:

\codefrom{rapport}{definitions}{equal}

Ce genre de fonctions sont très fastidieuses à rédiger et l'on constate déja la taille de celle ci
pour un type de donnée composé de deux éléments.
Si nous souhaitions écrire cette fonction le type ``tag'' \todo{peut etre changer la police} dans
la section \ref{representation des donnees} la perte de temps serait considérable.
Dans Coq il existe une commande qui va nous permettre de générer cette fonction
automatiquement, la voici:

\codefrom{rapport}{definitions}{SchemeEqual}



%%-------------Lemmes---------------
\subsection{Lemmes}
Voici un premier lemme qui nous sera très utile par la suite:
\codefrom{src}{ast_instructions}{tag_beq_different}
Ici on désire montrer que si l'on montre que deux étiquettes sont équivalentes
à l'aide de notre fonction sur les booléens alors on peut obtenir une preuve
de cette égalité dans le monde propositionnel.









%%----------------------------------------Section Conversion N liste B -----------------------------
\section{Conversion N liste B}





Code de bitn
\codefrom{src}{binary}{bitn}

Code de nbit
\codefrom{src}{binary}{nbit}


Parler du fait que pour ces lemme on a des effets de bords dont on est obligé
de faire des lemmes en prennant cela en compte 

Le but est de prouver un Lemme de cette forme
\codefrom{src}{binary}{nbitn}

et celui dans le sens opposé 
\codefrom{src}{binary}{bitnbit}






\section{Conversion Opcode liste B}
\label{partieOpcode}

La première étape d'encodage ou de décodage d'une instruction se situe
au niveau de l'étiquette. Dans le cas de MMIX comme vus en section \ref{partieMMIX}
une étiquette est associée à un unique opcode. Une façon de stocker cette
correspondance est d'utilisé des paires.
\codefrom{src}{association_list}{assoc}

Nous avons maintenant une représentation pour les associations il nous faut
maintenant stocker l'ensemble de celles ci. Etant donné que le nombre
d'instructions est de 256 utilisé une représentation sous forme
de liste est envisageable. Un argument supplémentaire est que la liste
est un type inductif qui nous permettra de raisonner plus aisement
lors des preuves étant donné sa relative simplicité.
Nous obtenons donc le type suivant pour représenté notre collection d'association:

\codefrom{src}{association_list}{tag_opcode_assoc}

\remark{Pourquoi ne pas utiliser un dictionnaire, parceque ça ferait que dans un sens }

\remark{}



%TODO faire un paragraphe de pk il faut pas nécéssairement plus d'informations dans la liste
% d'association avec notre représentation des données.


Afin de convertir l'ensemble opérateurs en binaire il nous faut
un moyens de stocker cette correspondance.
Ici le nombre d'étiquettes distinctes est de 256 ce qui est un nombre
assez faible. Une liste d'association se révèle ici une solution viable
étant donné que la recherche



Pourquoi ne pas utiliser de dictionnaire, parceque nous pourrons utiliser
la liste pour obtenir une le code binaire associé à une étiquette mais aussi faire
l'opération inverse


\section{Encode Decode}

\section{Conclusion}

\end{document}
               
